### bigbanana 

这题就是一个非常简单的vm题，主要考察选手耐心和动态调试的能力，题目难度是签到，看懂了操作的指令之后其实非常简单。

实际上程序做的事情就是存数据，异或解密数据，打印提示字符，不过这一部分在输入之后所以其实可以不用管，直接从输入后开始调试。

```
F4, 01 ⽴即数加法
F3 两个数异或
F2 cmp 后⾯跟着应该的结果
FE 对cmp的结果进行check
F0 把上⼀次结果保存
10 getchar并推上栈
F8 push 栈[0]字符
F7 push 栈[1]字符
```

用心分析会发现，所有的数都是对地址值进行操作的，所以前一轮的加密会对后一轮的加密有影响，不过看大家好像都是直接爆破的（

```python
key=[11,44,33,22]
data0=[48667259,
 47535509,
 46403677,
 45272035,
 44140263,
 43008497,
 41876732,
 40744760,
 39613168,
 38481281,
 37349478,
 36217409,
 35085942,
 33953875,
 32822192,
 31690302,
 30558628,
 29426748,
 28294937,
 27163367,
 26031402,
 24899631,
 23767992,
 22635950,
 21504381,
 20372636,
 19240500,
 18108814,
 16977052,
 15845189,
 14713579,
 13581602,
 12450038,
 11318240,
 10186440,
 9054537,
 7922892,
 6791100,
 5658982,
 4527307,
 3395498,
 2263629,
 1953788496]
data1=[48667228,
 47535432,
 46403636,
 45271840,
 44140044,
 43008248,
 41876452,
 40744656,
 39612860,
 38481064,
 37349268,
 36217472,
 35085676,
 33953880,
 32822084,
 31690288,
 30558492,
 29426696,
 28294900,
 27163104,
 26031308,
 24899512,
 23767716,
 22635920,
 21504124,
 20372328,
 19240532,
 18108736,
 16976940,
 15845144,
 14713348,
 13581552,
 12449756,
 11317960,
 10186164,
 9054368,
 7922572,
 6790776,
 5658980,
 4527184,
 3395388,
 2263592,
 1131796]
a=125
flag=""

for i in range(len(data1)-1):
    a=((a+key[i%4])^data0[i])-key[(i+1)%4]-key[(i+1)%4]-data1[i]
    flag+=chr(a)
flag=flag[-1::-1]
print(flag,end=" ")

```



这是使用最后一位字符`}`进行反推得到的，这里已经可以猜到flag了,由于前两位字符的运算并没有使用key，所以要单独写，不过加密方法完全相同，这里不再赘述。

### Long long call

### WriteUp

一、总体思路

re签到题，重点在于添加了一系列垃圾指令，分散了实际函数逻辑。这个混淆方法的大致原理可以看[这篇](https://blog.dx39061.top/2022/12/利用返回地址进行ret跳转的简单控制流混淆/)，唯一的修改是这次在最后插入了`leave ret` 指令，使IDA错误地识别成一个个嵌套的函数。预期做法是写IDAPython脚本去除垃圾指令，最后F5即可看见加密逻辑，这种方法可以看`maet radiv` 队伍的wp，写得很清楚了。但这道题作为签到，并没有写复杂的逻辑，其实纯调试也能看出来异或的逻辑，并且很多队伍都是这么做的。

二、细节要点

1. 反调试

LD_PRELOAD检测：之所以有这个点，其实是因为在check逻辑里每check一位，程序就会sleep一段时间。当时想可能会有师傅用LD_PRELOAD hook掉sleep，但是题目太简单了，好像也没有队伍在意这个点。

TracePid反调试：ELF文件最基本的反调试手段之一，这个就很常规了，也很好绕过，直接patch或者改返回值都行。

1. 加密逻辑：

处理掉垃圾指令或者直接调试应该比较容易看出来，这里直接放我的源码了：

```Python
void encrypt(uint8_t *input) {
    for (int i = 0; i < 44; i += 2) {
        uint8_t x = input[i] + input[i + 1];
        input[i] ^= x;
        input[i + 1] ^= x;
    }
}
```

由于相加容易导致溢出，所以没法写decrypt函数。赛后才意识到，两位一组加密还是太简单了，很多队伍都直接开爆了，但是作为签到也就无所谓了。预期是用z3求解，提交wp的队伍基本只有`maet radiv`是预期了，也是唯一一个完全按照我出题时想法解题的队伍了，心有灵犀了属于是。

下面放一个脚本：

```Python
from z3 import *
import copy

enc = [187, 191, 185, 190, 195, 204, 206, 220, 158, 143, 157,
       155, 167, 140, 215, 149, 176, 173, 189, 180, 136, 175,
       146, 208, 207, 161, 163, 146, 183, 180, 201, 158, 148,
       167, 174, 240, 161, 153, 192, 227, 180, 180, 191, 227]

s = Solver()

input = [BitVec(f'input[{i}]', 8) for i in range(44)]
input_ref = copy.deepcopy(input)

for i in range(0, 43, 2):
    x = (input[i] + input[i+1]) & 0xff
    input[i] = input[i] ^ x
    input[i] &= 0xff
    input[i+1] = input[i+1] ^ x
    input[i+1] &= 0xff

for i in range(44):
    s.add(input[i] == enc[i])

s.check()
m = s.model()
flag = "".join(chr(m[input_ref[i]].as_long()) for i in range(len(m)))
print(flag)
```

### RustedRobot
MainActivity 加载了so，输入的flag传入invokecheck
```java
static {
        System.loadLibrary("myrust");
        }
```
找到逻辑
Java_com_doctor3_androidrusttest_MainActivity_invokeCheck 

sub_2EEDF0(&unk_1F5550, 16LL);
sub_2DFB9C(v44);
将输入字符串转化为rs字符放入vec加了1然后转回jstring调用encrypt([Ljava/lang/String;)V

找CryptoClass，发现AES
解密即可
### Long long call
一、总体思路
re签到题，重点在于添加了一系列垃圾指令，分散了实际函数逻辑。这个混淆方法的大致原理可以看这篇，唯一的修改是这次在最后插入了leave ret 指令，使IDA错误地识别成一个个嵌套的函数。预期做法是写IDAPython脚本去除垃圾指令，最后F5即可看见加密逻辑，这种方法可以看maet radiv 队伍的wp，写得很清楚了。但这道题作为签到，并没有写复杂的逻辑，其实纯调试也能看出来异或的逻辑，并且很多队伍都是这么做的。
二、细节要点
1. 反调试
   LD_PRELOAD检测：之所以有这个点，其实是因为在check逻辑里每check一位，程序就会sleep一段时间。当时想可能会有师傅用LD_PRELOAD hook掉sleep，但是题目太简单了，好像也没有队伍在意这个点。
   TracePid反调试：ELF文件最基本的反调试手段之一，这个就很常规了，也很好绕过，直接patch或者改返回值都行。
2. 加密逻辑：
   处理掉垃圾指令或者直接调试应该比较容易看出来，这里直接放我的源码了：
```python
from z3 import *
import copy

enc = [187, 191, 185, 190, 195, 204, 206, 220, 158, 143, 157,
       155, 167, 140, 215, 149, 176, 173, 189, 180, 136, 175,
       146, 208, 207, 161, 163, 146, 183, 180, 201, 158, 148,
       167, 174, 240, 161, 153, 192, 227, 180, 180, 191, 227]

s = Solver()

input = [BitVec(f'input[{i}]', 8) for i in range(44)]
input_ref = copy.deepcopy(input)

for i in range(0, 43, 2):
    x = (input[i] + input[i+1]) & 0xff
    input[i] = input[i] ^ x
    input[i] &= 0xff
    input[i+1] = input[i+1] ^ x
    input[i+1] &= 0xff

for i in range(44):
    s.add(input[i] == enc[i])

s.check()
m = s.model()
flag = "".join(chr(m[input_ref[i]].as_long()) for i in range(len(m)))
print(flag)
```


### OLLessVM && OBF_REVENGE
不是Ollvm，只是一个基于块的混淆
控制流中多了很多 cmp jnz 等，是很明显的分发结构。然而貌似由于没有明显的主分发器和预处理器，看起来控制流没有那么美观。还有个非常明显的特征就是里面多了很多对于 cf 寄存器和 rax 寄存器的操作，例如 pushf popf 等
进行对汇编代码的分析，可以看出，程序一样拥有序言部分，固定为

push rax
pushf
mov eax, 0

还有个更加明显的特征，就是在执行每一个真实快之前都会有一个恢复寄存器的操作，每一个真实块的后面都会接上一个保护寄存器的操作，究其原因，是因为其分发使用了 cmp 指令，并使用 eax 寄存器作为分发变量，因此在分发的过程中会破坏原来的 eax 值和 cf 寄存器，要将他们存在栈中，等待下次执行真实块的时候取出使用。并且序言的作用也是一样，是为了保护调用函数时的寄存器环境 
#### 总体思路
首先获取并记录所有的真实块，我使用了 capstone 来进行反汇编获取指令

然后还要记录所有需要 patch 的地方，也就是所有做了保护寄存器操作的地方，因为我们其实只需要知道执行了这些保护寄存器操作之后，再接下来会执行到哪个真实块即可（因为原来的条件分发已经在保护寄存器操作之前就已经完成了，所以没有关系）

从这些地方开始，我们可以进行模拟执行，看看接下来会执行到哪个真实块

最后 patch 每个块中用于保护寄存器的位置为 jmp 到下一个真实块

之后函数开头 patch 成跳转到原来函数开头，其他的指令 nop 掉（感觉好像不 nop 掉也不影响。。。），就可以了

详细代码见https://github.com/doct0r3/DeCatraz/blob/master/main.py