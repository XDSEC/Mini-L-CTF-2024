# miniL-CTF   crypto  cx330

## ezfactor

emmm，题目描述非常清楚，第一步思路非常清楚。。。。。。知道了p和q的乘积n，很符合coppersmith攻击的条件，然后分解之后呢，就是解这组二元二次不定方程。难崩，感觉有点难解，经过翻阅很多很多的资料后发现，有个叫做 `cornacchia algorithm`的算法，完全符合这种情况。不过既然我们把p和q都分解出了，那么肯定会用到。因为该算法第一步是算一个二次剩余，但是n不是素数，所以不能直接算，所以用到crt，分开求解二次剩余之后，再用crt把他们加起来然后就差不多可以解出来了。后面就是常规的解AESd的CBC求解了。

```
from sage.all import*
from sympy.ntheory.residue_ntheory import nthroot_mod
from Crypto.Cipher import AES
from Crypto.Util.number import*
from gmpy2 import iroot
#用tonelli完成对二次剩余的求解
def tonelli(n, p):
    def legendre(a, p): 
        return pow(a, (p - 1) // 2, p)

    assert legendre(n, p) == 1
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(n, (p + 1) // 4, p)
    for z in range(2, p):
        if p - 1 == legendre(z, p):
            break
    c = pow(z, q, p)
    r = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    t2 = 0
    while (t - 1) % p != 0:
        t2 = (t * t) % p
        for i in range(1, m):
            if (t2 - 1) % p == 0:
                break
            t2 = (t2 * t2) % p
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r
n = 1612520630363003059353142253089981533043311564255746310310940263864745479492015266264329953981958844235674179099410756219312942121244956701500870363219075525408783798007163550423573845701695879459236385567459569561236623909034945892869546441146006017614916909993115637827270568507869830024659905586004136946481048074461682125996261736024637375095977789425181258537482384460658359276300923155102288360474915802803118320144780824862629986882661190674127696656788827
ph = 484571358830397929370234740984952703033447536470079158146615136255872598113610957918395761289775053764210538009624146851126
phh = ph*(2**360)
e = 107851261855564315073903829182423950546788346138259394246439657948476619948171
kbits = 360 
Flag = '725039090b61b83a729d1e1061de62f0aae6b3c13aa601e2302b88393a910086497ccb4ef1e8d588a0fffe1e7b2ac46e'
PR = PolynomialRing(Zmod(n),names = ('x'));(x,) = PR._first_ngens(1)
f = x + phh
'''这个找根是最艰难的一步，beta一般在0.45左右，epsilon是0到beta/7之间，，，这题数据不好，一般0.4的beta和beta/7都能解决，这个不行只能去尝试参数，一个晚上多的时间给试出来的'''
pl = f.small_roots(X = 2**360,beta = 0.45,epsilon = 0.02)
p = pl + phh
q = n//p
#接下来求解t，应该会有四格结果，但我只求了前两个就把答案求出来了
t11 = tonelli(-e,p)
t12 = -tonelli(-e,p)
t21 = tonelli(-e,q)
t22 = -tonelli(-e,q)
t1 = crt([t11,t21],[p,q])
t2 = crt([t11,t22],[p,q])
t3 = crt([t12,t21],[p,q])
t4 = crt([t12,t22],[p,q])
#print(iroot(n,2))计算一下n
n_sqrt=1269850633091547133301606731362018142512103252922869075310459320888372244323440591981587754187907664409987202464385267951032043538974982937608421693852927145910168582140810144946386790818179975545366217134697647490855055602161158182
#找到欧几里得定理中的第一个比n小的r,写一个这样的函数
def gcd_remainders_less_than_c(a, b, c):
    remainders = []
    x, y = a, b
    while y != 0:
        remainders.append(x % y)
        x, y = y, x % y
    return [r for r in remainders if r < c]
#求解x1，y1
xx1 = gcd_remainders_less_than_c(n,t1,n_sqrt)
x1 = 1243870455661141608893855070557839086246162016026646891004740243323979806583630368659138543225124700872421808131694462957949816026270215842094264408586035740517562990176484607865800539285640850695219286197707581151249724674290490156
yy1 = (n-x1**2)//e
#y1是yy1的开根号，这个要自己去看看`cornacchia algorithm`
y1 = 778156564233797998770389363155933130131586458935410804277214821408862616006174595552266453473226952271077865956328989592717545706675787432965454756055747736655112343654245502897778619493687839
print(y1)
#2222
xx2 = gcd_remainders_less_than_c(n,t2,n_sqrt)
x2 = 182253659410075767163781731348962945091846577076414933042404738598794833125615332279454886991427924837051597867173289861208069302705320896032549228163070699088015697887926632834855906475586696540265191236832154799224881829553449956
yy2 = (n-x2**2)//e
y2 = 3826663592883201362242052982911019030895844595602917808237884301002610074960760484903578912928832850081917030387203114706137342793446925345486883622189582436658206835889366640722677556888393889
key = long_to_bytes(x1+x2+y1+y2)[:16]
iv = long_to_bytes((x1^x2)+(y1^y2))[:16]
def decrypt_aes(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext.rstrip(b'\0')

# 加密后的文本
ciphertext = bytes.fromhex(Flag)
# 使用的AES密钥
key = key
# 使用的初始化向量（IV）
iv = iv # 将IV转换为字节串

decrypted_text = decrypt_aes(ciphertext, key, iv)
print("Decrypted text:", decrypted_text.decode('utf-8'))
```

## Modular

hhhhhh这个题目，嗯，，一开始看没什么思路，但是T的大比特和E的小比特相比来讲，也太逆天了想想要算s，知道了h，p，t。算s，嗯e好像不知道，但不知道的数它也太小了，抛开e不谈，s是由h产生的，那解题目肯定是要从h出发，h........化简一下，把逆元乘过去打开。嗯很明显要去构造格，然后去规约。那么格怎么构造呢，我等式右边的向量肯定要足够小，e也足够小，那么我把e放到目标向量里行吗？嗯。。。我们不妨试一试我们来构造这样的格子。（额，，不知道咋传图片，代码里面自己看吧）

```
t =  [11073785215399803853235061745025562471766281988061641769170576363313934679887217569801706599445660251521490126719635890179790621896844392956750809517990639, 12784423683616355098221440270623389347446777829352207702598822877935018742664765859424225840149743452815607228031166385525161497357580362090660087099463561, 7577732948268541787833560588485400689498904836182855054537116304468801803503701362142780756917159201619693280432140363109600711705084476590538898348091495, 10036538640393786727964860426918224804395694550532020220245239953525930433428030055698778916572386196731753524645673726564120152278880865190304242838501920, 10350368650118830326935007050127643692116265403962735788790668428564040409091749460517049732741049767368020817994528495057047372858538413379955184253035769, 13082554968320497009249783104283288691709656534267611249943658226578147441363459169752889315185021462154340729253550232757143969324177683836471761515296113, 11723150434377457341138045422253564051303981348922807490004982382654753129474768284517683118936761131376439630001542756355826193794438839584263048602040310, 2312593563786911571681233063720151667279804480769620841211384417877924447027383126968652725221072664250609182525144659105664559685824277385834372886285094, 8049485076552016296159857980961344802126929658650665671825539449229142359019667254159718901978033859414007639521459856787506712053910501662601618610514914, 12822523655335498062846821483569187428698965071054245766972798473300669853079078505565238968193164176053130900424396330887238266290091854068639522572449339, 1988079154144136979677332642795216452632297338094750910617093873182523143339869438995891613910990545752839876846627284570472460679615904755635544112116092, 9194005022626331512379119874845502249344166649769798000933209476153024446423815364991330602243774497089790879352599144546648334988413603137287141470786227, 11727206829831450157203317046245035552298279328303831066317871736717278323280297412293674926381591364506598009757202174628385178306540269839380835605774245, 11215884114131863628931482493525076575449310680468928386799247991075129949742646459804819103409234048309002257507655620363713887571426410650360692900914699, 13229252051259887566909445786745289385337948372770305233565261009723186917196139796699867121485348607425821132607169548715417088553975822119578238895523265, 2434133230340215157166799626659846713913609778121753977290859118021406007835503746444795101542893453323303681652821047182210814815480500209549189261212091]
h =  [127689167482288014000425602448716351832061686812439342522706528519984932610953307949977350023021888687983251179153954114903130408334900302125917604314161605704555174302412954096635321614161214385582921381486515033274321858036598915744458540554641638486064496964212510591699130814604388251826605946884931609239, 56413040451215992468023998497689962423937259634730422435837574010842048007293695901884911359124444138173478449239034017088644337562220927468594721047524149961827124075147838400693750768945802932499189371097807548365894469129746580626236019137090009004220729941666144085424522735838394947258817989463046580083, 159096117503489718963992325680213552682830013716063476625015908241930978596419248762838492502713441290032524915163962289091138236114604143819360187403692143046854081221922184032793094745439121739937527053820166175718197141255384894581172929886611605237834758037034390281470190860024729504992421640301133083404, 148614330434083992178131965309280278458335893214841048516035856106213897958541973680637125288066896832409976839772740287748661345292024159485776320225956338647921725106379463224642461406265568922245631807144160289351197425214555754580233288475579979258758527061759197292322910306030807023192166185587921285671, 123345966798742829864063791304200566491120706593219158548382987040598862749861728657659502537047580298796463849444588459425801502067157624710064438370936408393253024836355432534385142463869549691987813313361098037942855131514209362841779839493625734946204159916085515497669218464956693057910996989418368224718, 143730572425993961234876793125643776784767574870493801394069361432939095891758175702481539677359617673034631044084638831967344534252877445924666622233969641174369690202553271751772918142543732283676883488826667008492638895690040854698522971159686315980188834562253564620383944905979625152892744587185914741619, 1899333675825489355648956982427596214776139771238039023541139046760215434943108710292661083292292953429117286234729966131691913785686567736252854362355954922873970819020441817967086919426033302536398011099152039375012125999540633921013012116333257553654574739476224062806921065018986994063829525027823407648, 40021946460891456694763667739829844641491219915874879792778254614695339805691219947475184567199479881579252472064910345853968456976632175231245612205653295824088485229980359745332624808591401283855146511631022408273586520877407674644614613998690455052346136191115393887831117621257895456840650358274704555826, 12587255965576618872424846983892765361571446840329606167872576672371962359763011155165681721852152650809792269562777388435588015401100477502385787955972250368547408410489592248270305167054993487526965497026997328059292719829447657379952511915845044662968837407738496706780296294079791108598328537710381157919, 35373123117894082903769877421701955286540504796790597579883645896246184957279758828485780634720987127549717035820445126876568629689752869185045633419105196626182281116564659179017183846877215180869022831602437473904695745472745901533685175353016286208073998879110512700881415857098355556619716927272875712543, 134932924556053419947479552023990513361719644723460306853893813536315826606671396974575808371962061681863431171645460950240068835345485082055042507057318484642248377464012190169846843382519054758782949721704286454756070440219919539517396121347211156022973464793745891250380424466962047539290876180276174954017, 27899997727957090644819589789584825770425643969528465008806641542434382954966398613498974641857103683569692073706544870428810334295672590103909799629869694715078979935157432679153773828133621666694959818824171709239244599243012260821032040518358082030953828035117001054087875399613540555646765816048615539771, 7990260348729651065061774330514759509564837031091710787389017717183671432285163356986386067690017705747754893027235277280940946101800970816540560960119674128607348218440305393345959072544795513286812841410488767361374115717105992844205502565330711799795306905954106878365241897255454156656558563160409751399, 27068508791948756691803985700118866000386053120093908814487276298724757390487696031090900109841931605137365394815754358395620936879082992913896989240280854388738478132736076967155970572855435930485296183348479074877371237239722477255173805754299750182013036348100323337537900501322375563232654474595361640515, 13068380881558918013590945724589640458561504299404063853219448769281966209348511384884736841017603963103299381103791221248018581424389899807981567417759391600600984972983942688701208630779299513897011464626036238552507148124206493947096118137357598103691906343263150876734284019870558697515292943970868900740, 144432759930368947380264594980501091338004849606824563808700906729893535126944352004834658811698724817007929870819639919440203958980489826241756941893529760770624315120979622281316834874867192315134768359044211887340768352160881022324364858511458276652532183301934534104684508521052564120793282785818867643234]
p = 164845988554803570034210932437537368454111382224593662888381752205097830374220032126019668095170780104196793308898619165077628440843625297811060080191510695127294662392565386869488665989314790417153155199484603115711496029502166530435242963549027629739137822533436875021838499822082806570509681528804270137211
iv =  '27d72ebeda75d7dc922c928f151d2db0'
encrypt_flag =  '94cec3dc63fba1e8383852d852468d25ed7a2e05b4006d6162c3fcd4bef2565a'

from hashlib import sha256
from sage.all import*

from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
M = Matrix(ZZ,18,18)
for i in range(0,16):
    M[i,i] = p
    M[-1,i] = h[i]*t[i]
    M[-2,i] = h[i]
    M[-1,-1] = 2**1024
    M[-2,-2] = 1
M = M.LLL()
for i in range(0,18):
    if M[i,-1] == 2**1024:
        s = M[i,-2]
#print(s)
key = sha256(long_to_bytes(s)).digest()[:16]
def decrypt_aes(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext.rstrip(b'\0')

# 加密后的文本
ciphertext = bytes.fromhex(encrypt_flag)

# 使用的AES密钥
key = key

# 使用的初始化向量（IV）
iv = bytes.fromhex('27d72ebeda75d7dc922c928f151d2db0')  # 将IV转换为字节串

decrypted_text = decrypt_aes(ciphertext, key, iv)
print("Decrypted text:", decrypted_text.decode('utf-8'))

```

# MinTrix

## ```

'''题目输出了明文.pkA.还有pkB.两个公钥都是有矩阵乘积而组成的。而私钥的求解.和矩阵A和矩阵B的求解关系很大。所以想着能不能将A*B的乘积分解。回到A和B的生成过程.我们会发现矩阵中的元素是在一个素数群下产生的.而在网上看了看.发现素数群下生成的矩阵很多都是满秩的。那么很大概率下.A和B是满秩的(可以去验证一下.找一下A*B的秩的行了.发现正好是66).那么A和B的性质就搞懂了。怎么分解呢。谷歌搜索很多之后.发现了名为;行简化行列式的秩分解。发现和题目很适配，感觉就是这个方向，于是动手实践'''

```
from sage.all import*
import os
import pickle

from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
#打开sobj文件
data = load('/root/CTF/output.sobj')
pkA = data[0]
pkB = data[1]
ct = data[2]
#print(ct)
#分解m乘m的矩阵，因为在素数群下，所以m乘n的矩阵和n乘m的矩阵大概率是满秩的。（还没有验证，先进行矩阵分解的函数）
#第一步输出A矩阵
def find_A(matrix_input):
    a = matrix_input.rref()
    main_elements = [next((elem for elem in row if elem != 0), None) for row in a.rows()]
    non_main_columns = [j for j in range(a.ncols()) if j not in [row.list().index(main_element) for row, main_element in zip(a.rows(), main_elements) if main_element is not None]]
    return matrix_input.delete_columns(non_main_columns)

#输出B
def find_B(matrix):
    matrix = matrix.rref()
    zero_rows = []
    for i, row in enumerate(matrix):
        if all(elem == 0 for elem in row):
            zero_rows.append(i)
    matrix = matrix.delete_rows(zero_rows)
    return matrix
#找到sk
def find_sk(pk):
    sk = []
    for i in range(0,4):
        sk.append((find_A(pk[i]),find_B(pk[i])))
    return sk
skA = find_sk(pkA)
skB = find_sk(pkB)

#print(find_A(pkA[0]).ncols())

def dh(sk, pk):
    shared = []
    for csk, cpk in zip(sk, pk):
        A, B = csk
        shared.append((A.transpose() * cpk * B.transpose()).det())
    return shared

shA = dh(skA, pkB)
shB = dh(skB, pkA)
print(shA)
print(shB)
#生成shard
#print(shA)
shared = b"".join(long_to_bytes(int(x)) for x in shA)
print(ct)
print(shared)
ct_hex = '1798bb4cbca945a8e33a68aa8e462f66f5230f8fccc2f0938c04bac8fad45fb9952ba14a94c85a90c7845ec43b10b017'

# 已知的key
known_key = b'FN\x9dy\x8a\x9a#\xbcRd\x95\xb89\xa6\xf9\x08'

# 将16进制密文字符串转换为字节类型
ct = bytes.fromhex(ct_hex)

# 将已知的key转换为字节类型
shared = known_key

# 创建AES对象
cipher = AES.new(known_key, AES.MODE_ECB)

# 解密
plain_text = cipher.decrypt(ct)

# 输出解密后的明文
print(plain_text.decode('utf-8'))
```
